### Типы данных

<mark> Заметка </mark> Переполнение беззнакового типа предугадать возможно, но переполнение знакового типа несет непредсказуемый характер

<mark> Заметка </mark> Для явного приведения типа используется оператор `static_cast<T>`:

```cpp
double q = static_cast<double>(a) / b;
```

###### Простые типы

```cpp
char c = '1';    // символ (1 байт)
bool b = true;   // логическая переменная, принимает значения false и true (1 байт)
int i = 42;      // целое число (занимает, как правило, 4 байта)
short int si = 17;           // короткое целое (занимает 2 байта)
long li = 12321321312;       // длинное целое (как правило, 8 байт)
long long lli = 12321321312; // длинное целое (как правило, 8 байт)
float f = 2.71828;           // дробное число с плавающей запятой (4 байта)
double d = 3.141592;         // дробное число двойной точности (8 байт)
long double ld = 1e15;       // длинное дробное (как правило, 16 байт)
```

###### Получение лимитов

```cpp
#include <iostream>
#include <limits>  // необходимо для numeric_limits

int main() {
    // посчитаем для типа int:
    std::cout << "minimum value: " << std::numeric_limits<int>::min() << "\n"
              << "maximum value: " << std::numeric_limits<int>::max() << "\n";
}
```

###### Корректное сравнение чисел с плавающей запятой

```cpp
#include <cmath>

// ...

double delta = 0.0000001;
if (std::abs(val1 - val2) < delta)
    std::cout << "Равно" << std::endl;
else 
    std::cout << "Неравно" << std::endl;
```

### Считывание данных

###### Считывание до конца ввода

```cpp
int x;
while (std::cin >> x) {
    //...
}
```

###### Считывание построчно до конца ввода

```cpp
#include <string>

std::string name;
while (std::getline(std::cin, name)) {
    //...
}
```

### Контейнеры `vector` и `string`

###### Инициализация

```cpp
vector<std::string> v1;  // пустой вектор строк
vector<int> data = {1, 2, 3, 4, 5};
vector<std::string> v2(5);  // вектор из пяти пустых строк
vector<std::string> v3(5, "hello");  // вектор из пяти строк "hello"
```

###### Полезные функции

Количество элементов

```cpp
data.size();
```

Получение элемента по индексу (при неправильном индексе вылезет ошибка)

```cpp
data.at(index);
```

Получение крайних элементов

```cpp
data.front();     // data[0]
data.back();      // data[data.size() - 1]
```

Проверка на пустоту

```cpp
data.empty();
```

Удаление и добавление элементов

```cpp
data.push_back(el);    // Добавление элемента в конец
data.pop_back();       // Удаление конечного элемента

data.insert(pos, el);  // Вставка на позицию и сдвиг вправо элементов
// По-моему в vector erase работает только с итераторами
// А в string еще и с позициями
data.erase()           // Удаление элемента на позиции и сдвиг влево

data.resize(len);      // Изменение размера вектора и отбрасывание элементов с конца

data.clear();          // Очистка вектора
```

###### Резервирование памяти

Определение выделенного места под вектор

```cpp
data.capacity(); 
```

Резервирование нужного количества памяти

```cpp
data.reserve(elements_count); 
```

###### Дополнительные функции для `string`

Подстрока

```cpp
s.substr(5, 6); // 6 символов с 5-ой позиции
// "0123456789ABCDEF" -> "56789A"
//       ||||||

s.substr(12); // С 12-ой позиции до конца строки
```

Найти подстроку

```cpp
s.find("some string");         // Вернет позицию первого символа подстроки
s.find("ss", start_position);  // Начнет поиск со стартовой позиции
```

Вставка подстроки

```cpp
 s.insert(5, "std::");
```

Замена указанного диапазона на новую подстроку

```cpp
s.replace(0, 4, "Special");
```

Удаление подстроки

```cpp
s.erase(8, 5); // С 8 позиции 5 символов
```
